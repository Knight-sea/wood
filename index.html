<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <title>木こりと採取者 比率調整付きゲーム（修正版）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      margin: 0;
      background: #222;
      color: #ddd;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
    }

    canvas {
      background: #448844;
      display: block;
      margin: 10px auto;
      max-width: 100%;
      height: auto;
      border: 2px solid #224422;
      box-sizing: border-box;
      touch-action: none;
    }

    #woodCount {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      font-size: 18px;
      border-radius: 8px;
      color: #fff;
      user-select: none;
      z-index: 10;
      max-width: 90vw;
      white-space: nowrap;
    }

    #clearMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffcc00;
      text-shadow: 2px 2px 6px #000;
      font-weight: bold;
      display: none;
      user-select: none;
      z-index: 20;
      text-align: center;
      max-width: 90vw;
      word-wrap: break-word;
    }

    #controls,
    #buttonControls {
      position: fixed;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 12px;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      user-select: none;
      width: 180px;
      box-sizing: border-box;
      z-index: 10;
    }

    #controls {
      top: 50px;
    }

    #buttonControls {
      top: 130px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
    }

    #controls label {
      display: block;
      margin-bottom: 6px;
      white-space: nowrap;
    }

    #woodcutterCountDisplay {
      font-weight: bold;
      margin-top: 4px;
    }

    button {
      background-color: #444;
      border: 1.5px solid #666;
      color: #eee;
      padding: 8px 14px;
      margin: 0;
      font-weight: normal;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      width: 100%;
      box-sizing: border-box;
      user-select: none;
    }

    button:hover {
      background-color: #555;
    }

    @media screen and (max-width:600px) {

      /* canvas（マップ）は画面の上半分に収める */
      #gameCanvas {
        display: block;
        width: 100vw;
        height: 50vh;
        /* 画面高さの半分 */
        max-height: none !important;
        border: 2px solid #224422;
        box-sizing: border-box;
      }

      /* 木材表示は操作エリア内の上部に配置 */
      #woodCount {
        position: relative;
        /* 固定解除 */
        margin: 8px 0 4px 0;
        background: rgba(0, 0, 0, 0.6);
        padding: 6px 12px;
        font-size: 18px;
        border-radius: 8px;
        color: #fff;
        user-select: none;
        max-width: 90vw;
        white-space: nowrap;
      }

      /* 人数スライダーは操作エリアの中で表示 */
      #controls {
        position: relative;
        /* 固定解除 */
        width: 100%;
        max-width: 400px;
        background: rgba(0, 0, 0, 0.6);
        padding: 8px 12px;
        border-radius: 8px;
        color: #fff;
        font-size: 16px;
        user-select: none;
        box-sizing: border-box;
        margin-bottom: 8px;
      }

      #controls label {
        margin: 0 0 4px 0;
        white-space: normal;
        display: block;
      }

      /* ボタン群は横並び、小さめにして操作エリア内に収める */
      #buttonControls {
        position: relative;
        /* 固定解除 */
        width: 100%;
        max-width: 400px;
        display: flex;
        justify-content: space-between;
        gap: 8px;
        background: rgba(0, 0, 0, 0.6);
        padding: 6px 8px;
        border-radius: 8px;
        box-sizing: border-box;
      }

      #buttonControls button {
        flex: 1 1 0;
        font-size: 14px;
        padding: 8px 6px;
        margin: 0;
        min-width: 0;
        /* 横幅が広がりすぎないように */
      }

      /* 操作エリア全体を画面下半分に配置 */
      body {
        display: flex;
        flex-direction: column;
        height: 100vh;
        margin: 0;
      }

      main,
      #gameCanvas {
        flex-shrink: 0;
      }

      #controls,
      #woodCount,
      #buttonControls {
        flex-shrink: 0;
      }

      #controls,
      #woodCount,
      #buttonControls {
        margin-left: auto;
        margin-right: auto;
      }

      /* 操作部分を下半分の中央にまとめるためにwrapperを追加推奨 */
      /* もしwrapper要素を使えるなら */
      /*
  #uiWrapper {
    height: 50vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 8px;
  }
  */
    }
  </style>
</head>

<body>
  <div id="woodCount">木材: 0</div>
  <div id="clearMessage">Clear the game</div>

  <div id="controls">
    <label for="woodcutterCountRange">木こりの人数: <span id="woodcutterCountDisplay">10</span> / 20</label>
    <input type="range" id="woodcutterCountRange" min="0" max="20" value="10" step="1" />
  </div>

  <div id="buttonControls">
    <button id="startBtn">スタート</button>
    <button id="pauseBtn">一時停止</button>
    <button id="resetBtn">リセット</button>
  </div>

  <canvas id="gameCanvas" width="1200" height="900"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const woodCountDisplay = document.getElementById("woodCount");
      const clearMessage = document.getElementById("clearMessage");
      const woodcutterCountRange = document.getElementById("woodcutterCountRange");
      const woodcutterCountDisplay = document.getElementById("woodcutterCountDisplay");

      // マップ/タイル設定
      const TILE_SIZE = 30;
      const MAP_COLS = 40;
      const MAP_ROWS = 30;

      const TILE_GRASS = 0;
      const TILE_TREE = 1;
      const TILE_WOODCHIP = 2;

      // マップデータ: MAP_ROWS x MAP_COLS
      const mapData = new Array(MAP_ROWS).fill(0).map(() => new Array(MAP_COLS).fill(TILE_GRASS));

      // リソースと状態
      const woodResource = { count: 0 };
      let woodcutterCount = 10;
      let isRunning = false;
      let lastTime = performance.now();
      let plantTimerId = null;
      let startTime = null;

      // 市民クラス（あなたのクラスと類似）
      class Citizen {
        static reservedTargets = new Map();

        constructor(id, x, y) {
          this.id = id;
          this.x = x;
          this.y = y;
          this.state = "idle";
          this.target = null;
          this.speed = 5; // あなたのスピード倍数
          this.moveProgress = 0;
          this.nextX = x;
          this.nextY = y;
          this.harvestTime = 0;
        }

        update(delta) {
          switch (this.state) {
            case "idle": this.findTarget(); break;
            case "moving": this.moveStep(delta); break;
            case "harvesting":
              this.harvestTime -= delta;
              if (this.harvestTime <= 0) this.finishHarvest();
              break;
            case "collecting":
              this.harvestTime -= delta;
              if (this.harvestTime <= 0) this.finishCollect();
              break;
          }
        }

        static findAvailableTarget(candidates) {
          for (const pos of candidates) {
            const key = `${pos.x},${pos.y}`;
            if (!Citizen.reservedTargets.has(key)) return pos;
          }
          return null;
        }

        findTarget() {
          // すでにターゲットがある場合は検索しない
          if (this.target) return;

          let candidates = (this.id <= woodcutterCount) ? findAllTiles(TILE_TREE) : findAllTiles(TILE_WOODCHIP);

          candidates.sort((a, b) => (Math.abs(a.x - this.x) + Math.abs(a.y - this.y)) - (Math.abs(b.x - this.x) + Math.abs(b.y - this.y)));

          let targetPos = Citizen.findAvailableTarget(candidates);

          if (!targetPos) {
            // 時々草に戻る
            if (Math.random() < 0.5) {
              candidates = findAllTiles(TILE_GRASS);
              candidates.sort((a, b) => (Math.abs(a.x - this.x) + Math.abs(a.y - this.y)) - (Math.abs(b.x - this.x) + Math.abs(b.y - this.y)));
              targetPos = Citizen.findAvailableTarget(candidates);
              if (!targetPos) { this.state = "idle"; return; }
            } else { this.state = "idle"; return; }
          }

          const key = `${targetPos.x},${targetPos.y}`;
          Citizen.reservedTargets.set(key, this.id);
          this.target = targetPos;
          this.state = "moving";
          this.moveProgress = 0;
        }

        moveStep(delta) {
          if (!this.target) { this.state = "idle"; return; }

          if (this.moveProgress === 0) {
            if (this.x !== this.target.x) {
              this.nextX = this.x + (this.target.x > this.x ? 1 : -1);
              this.nextY = this.y;
            } else if (this.y !== this.target.y) {
              this.nextX = this.x;
              this.nextY = this.y + (this.target.y > this.y ? 1 : -1);
            } else {
              const key = `${this.target.x},${this.target.y}`;
              if (Citizen.reservedTargets.get(key) === this.id) Citizen.reservedTargets.delete(key);

              if (this.id <= woodcutterCount && mapData[this.y][this.x] === TILE_TREE) {
                this.state = "harvesting";
                this.harvestTime = 0.4;
              } else if (this.id > woodcutterCount && mapData[this.y][this.x] === TILE_WOODCHIP) {
                this.state = "collecting";
                this.harvestTime = 0.4;
              } else {
                this.state = "idle";
              }
              this.target = null;
              this.moveProgress = 0;
              return;
            }
          }

          this.moveProgress += this.speed * delta;
          if (this.moveProgress >= 1) {
            this.x = this.nextX;
            this.y = this.nextY;
            this.moveProgress = 0;
          }
        }

        finishHarvest() {
          if (mapData[this.y][this.x] === TILE_TREE) mapData[this.y][this.x] = TILE_WOODCHIP;
          this.state = "idle";
        }

        finishCollect() {
          if (mapData[this.y][this.x] === TILE_WOODCHIP) {
            woodResource.count++;
            mapData[this.y][this.x] = TILE_GRASS;
            woodCountDisplay.textContent = `木材: ${woodResource.count}`;

            // クリア判定
            if (woodResource.count >= 1000) {
              clearMessage.style.display = "block";
              pauseGame();

              // 経過時間を計算
              let endTime = performance.now();
              let elapsedSeconds = ((endTime - startTime) / 1000).toFixed(2);

              // メッセージにタイム追加
              clearMessage.innerHTML = `CLEAR THE GAME!!<br>タイム: ${elapsedSeconds} 秒<br>制作者：Summersea`;
            }
          }
          this.state = "idle";
        }


        draw(ctx) {
          let drawX = this.x, drawY = this.y;
          if (this.state === "moving" && this.moveProgress > 0) {
            drawX = this.x + (this.nextX - this.x) * this.moveProgress;
            drawY = this.y + (this.nextY - this.y) * this.moveProgress;
          }
          const px = (drawX + 0.5) * TILE_SIZE;
          const py = (drawY + 0.5) * TILE_SIZE;

          let color = "#aaaaaa";
          if (this.id <= woodcutterCount) {
            if (this.state === "harvesting") color = "#ffaa00";
            else if (this.state === "moving") color = "#ffcc33";
            else color = "#ffd18a";
          } else {
            if (this.state === "collecting") color = "#3399ff";
            else if (this.state === "moving") color = "#66bbff";
            else color = "#9fd1ff";
          }

          ctx.beginPath();
          ctx.arc(px, py, TILE_SIZE * 0.4, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.fillStyle = "#000";
          ctx.font = "12px monospace";
          ctx.fillText(this.id, px - 5, py + 4);
        }
      } // class end

      function findAllTiles(tileType) {
        const results = [];
        for (let y = 0; y < MAP_ROWS; y++) {
          for (let x = 0; x < MAP_COLS; x++) {
            if (mapData[y][x] === tileType) results.push({ x, y });
          }
        }
        return results;
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      // ランダムな草タイルに木を植える
      function plantRandomTrees() {
        const grassTiles = findAllTiles(TILE_GRASS);
        if (grassTiles.length === 0) return;
        shuffleArray(grassTiles);
        const count = Math.min(10, grassTiles.length);
        for (let i = 0; i < count; i++) {
          const pos = grassTiles[i];
          mapData[pos.y][pos.x] = TILE_TREE;
        }
      }

      // initial map/citizen setup helpers
      const citizens = [];

      function initMap() {
        for (let r = 0; r < MAP_ROWS; r++) {
          for (let c = 0; c < MAP_COLS; c++) {
            mapData[r][c] = Math.random() < 0.25 ? TILE_TREE : TILE_GRASS;
          }
        }
        // オプション: 最低限の数の木を確保する
        // （必須ではありませんが、必要に応じてここに追加で植えることができます）
      }

      function initCitizens() {
        citizens.length = 0;
        for (let i = 0; i < 20; i++) {
          let x, y;
          do {
            x = Math.floor(Math.random() * MAP_COLS);
            y = Math.floor(Math.random() * MAP_ROWS);
          } while (mapData[y][x] !== TILE_GRASS);
          citizens.push(new Citizen(i + 1, x, y));
        }
      }

      function initGame() {
        // 計測開始時間を記録
        startTime = performance.now();

        // この下に今までの初期化処理（マップ生成、住民生成など）が続く

        woodResource.count = 0;
        woodCountDisplay.textContent = `木材: 0`;
        clearMessage.style.display = "none";
        isRunning = false;
        Citizen.reservedTargets.clear();

        initMap();
        initCitizens();

        // 開始前にページがすべて緑にならないようにするための初期描画
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        citizens.forEach(c => c.draw(ctx));
      }

      function drawMap() {
        for (let r = 0; r < MAP_ROWS; r++) {
          for (let c = 0; c < MAP_COLS; c++) {
            switch (mapData[r][c]) {
              case TILE_GRASS: ctx.fillStyle = "#336633"; break;
              case TILE_TREE: ctx.fillStyle = "#225522"; break;
              case TILE_WOODCHIP: ctx.fillStyle = "#997733"; break;
              default: ctx.fillStyle = "#336633";
            }
            ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = "#224422";
            ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }

      // サイズ変更: 内部解像度を固定します (列数 * タイル数 / 行数 * タイル数)
      // CSS の表示サイズをウィンドウに収まるように調整しますが、描画には元のピクセルを使用します (ぼやけを防ぎます)
      function resizeCanvas() {
        const marginRight = window.innerWidth <= 600 ? 0 : 220; // if narrow, controls stack above so no reserved width
        const maxWidth = window.innerWidth - marginRight - 20;
        const maxHeight = window.innerHeight - 20;
        const originalWidth = MAP_COLS * TILE_SIZE;
        const originalHeight = MAP_ROWS * TILE_SIZE;
        const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight, 1);
        canvas.style.width = (originalWidth * scale) + "px";
        canvas.style.height = (originalHeight * scale) + "px";
        // 内部解像度を同じに保つ（再描画が完全な詳細で機能するため）
        canvas.width = originalWidth;
        canvas.height = originalHeight;
      }

      //メインループ: 常に次のフレームをスケジュールしますが、更新ロジックはisRunningの場合にのみ実行されます。
      function mainLoop() {
        const now = performance.now();
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        if (isRunning) {
          citizens.forEach(c => c.update(delta));
        }

        // 常に描画する（一時停止中でも UI が更新される）
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        citizens.forEach(c => c.draw(ctx));

        requestAnimationFrame(mainLoop);
      }

      // プラントタイマー: 継続的に実行されますが、isRunning のときのみマップを変更します。
      function startPlantTimer() {
        if (plantTimerId) clearInterval(plantTimerId);
        plantTimerId = setInterval(() => {
          if (isRunning) plantRandomTrees();
        }, 1000);
      }

      function pauseGame() {
        isRunning = false;
      }

      // UI event bindings
      document.getElementById("startBtn").addEventListener("click", () => {
        if (!isRunning) {
          isRunning = true;
          lastTime = performance.now();
        }
      });
      document.getElementById("pauseBtn").addEventListener("click", () => {
        isRunning = false;
      });
      document.getElementById("resetBtn").addEventListener("click", () => {
        isRunning = false;
        initGame();
      });

      woodcutterCountRange.addEventListener("input", (e) => {
        woodcutterCount = parseInt(e.target.value, 10);
        woodcutterCountDisplay.textContent = woodcutterCount;
        citizens.forEach(c => { c.state = "idle"; c.target = null; c.moveProgress = 0; });
        Citizen.reservedTargets.clear();
      });

      window.addEventListener("resize", resizeCanvas);

      // 初期起動
      initGame();
      resizeCanvas();
      startPlantTimer();
      mainLoop();

    })(); // 終了
  </script>
</body>

</html>